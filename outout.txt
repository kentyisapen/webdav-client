=================
##################################
./app/src/App.tsx
##################################

// src/App.tsx

import React from "react";
import { BrowserRouter as Router, Routes, Route } from "react-router-dom";
import { WebDAVProvider } from "./contexts/WebDAVContext";
import ConnectionScreen from "./components/Connection/ConnectionForm";
import FileExplorerScreen from "./components/FileExplorer/FileExplorer";

const App: React.FC = () => {
	return (
		<WebDAVProvider>
			<Router>
				<Routes>
					<Route path="/" element={<ConnectionScreen />} />
					<Route path="/explorer/*" element={<FileExplorerScreen />} />
				</Routes>
			</Router>
		</WebDAVProvider>
	);
};

export default App;


##################################
./app/src/App.test.tsx
##################################

import React from 'react';
import { render, screen } from '@testing-library/react';
import App from './App';

test('renders learn react link', () => {
  render(<App />);
  const linkElement = screen.getByText(/learn react/i);
  expect(linkElement).toBeInTheDocument();
});


##################################
./app/src/index.tsx
##################################

import React from 'react';
import ReactDOM from 'react-dom/client';
import './index.css';
import App from './App';
import reportWebVitals from './reportWebVitals';

const root = ReactDOM.createRoot(
  document.getElementById('root') as HTMLElement
);
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);

// If you want to start measuring performance in your app, pass a function
// to log results (for example: reportWebVitals(console.log))
// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals
reportWebVitals();


##################################
./app/src/contexts/WebDAVContext.tsx
##################################

// src/contexts/WebDAVContext.tsx

import React, { createContext, useState, ReactNode, useEffect } from "react";
import { createClient, WebDAVClient } from "webdav";

interface WebDAVContextProps {
	client: WebDAVClient | null;
	connect: (url: string) => Promise<void>;
	disconnect: () => void;
	baseUrl: string | null;
}

export const WebDAVContext = createContext<WebDAVContextProps>({
	client: null,
	connect: async () => {},
	disconnect: () => {},
	baseUrl: null,
});

export const WebDAVProvider: React.FC<{ children: ReactNode }> = ({
	children,
}) => {
	const [client, setClient] = useState<WebDAVClient | null>(null);
	const [baseUrl, setBaseUrl] = useState<string | null>(null);

	// 永続化: ローカルストレージからベースURLを読み込む
	useEffect(() => {
		const savedUrl = localStorage.getItem("webdav_url");
		if (savedUrl) {
			connect(savedUrl).catch(() => {
				// 接続失敗時は何もしない
				console.error("自動接続に失敗しました。");
			});
		}
	}, []);

	const connect = async (url: string) => {
		const newClient = createClient(url);
		// 接続確認のため、ルートディレクトリの一覧を取得
		await newClient.getDirectoryContents("/");
		setClient(newClient);
		setBaseUrl(url);
		localStorage.setItem("webdav_url", url); // ローカルストレージに保存
	};

	const disconnect = () => {
		setClient(null);
		setBaseUrl(null);
		localStorage.removeItem("webdav_url"); // ローカルストレージから削除
	};

	return (
		<WebDAVContext.Provider value={{ client, connect, disconnect, baseUrl }}>
			{children}
		</WebDAVContext.Provider>
	);
};


##################################
./app/src/components/FileExplorer/FileExplorer.tsx
##################################

// src/components/FileExplorer/FileExplorer.tsx

import React, { useContext, useEffect, useState } from "react";
import { WebDAVContext } from "../../contexts/WebDAVContext";
import { useNavigate, useLocation } from "react-router-dom";
import {
	AppBar,
	Toolbar,
	Typography,
	IconButton,
	Box,
	List,
	ListItem,
	ListItemIcon,
	ListItemText,
	Button,
	CircularProgress,
	Snackbar,
	Alert,
	Table,
	TableBody,
	TableCell,
	TableContainer,
	TableHead,
	TableRow,
	Paper,
	ToggleButton,
	ToggleButtonGroup,
} from "@mui/material";
import FolderIcon from "@mui/icons-material/Folder";
import InsertDriveFileIcon from "@mui/icons-material/InsertDriveFile";
import ArrowBackIcon from "@mui/icons-material/ArrowBack";
import UploadIcon from "@mui/icons-material/Upload";
import AddIcon from "@mui/icons-material/Add";
import DeleteIcon from "@mui/icons-material/Delete";
import DownloadIcon from "@mui/icons-material/Download";
import GridViewIcon from "@mui/icons-material/GridView";
import TableViewIcon from "@mui/icons-material/TableView";
import UploadModal from "../Upload/UploadModal";
import { getPathSegments } from "../../utils/helpers";
import { FileStat } from "webdav";
import Grid from "@mui/material/Grid2";

interface FileItem {
	basename: string;
	filename: string;
	type: string; // 'directory' or 'file'
	href: string;
}

const FileExplorerScreen: React.FC = () => {
	const { client, disconnect, baseUrl } = useContext(WebDAVContext);
	const [files, setFiles] = useState<FileItem[]>([]);
	const [loading, setLoading] = useState<boolean>(false);
	const [error, setError] = useState<string | null>(null);
	const [uploadOpen, setUploadOpen] = useState<boolean>(false);
	const [viewMode, setViewMode] = useState<"table" | "grid">("grid"); // 表示モードの状態
	const navigate = useNavigate();
	const location = useLocation();
	const currentPath =
		decodeURI(location.pathname.replace("/explorer", "")) || "/";

	useEffect(() => {
		if (!client || !baseUrl) {
			navigate("/");
			return;
		}

		const fetchFiles = async () => {
			setLoading(true);
			try {
				const contents = (await client.getDirectoryContents(
					currentPath
				)) as FileStat[];
				const mappedFiles: FileItem[] = contents.map((file: FileStat) => ({
					basename: file.basename,
					filename: file.filename,
					type: file.type,
					href: `${baseUrl}${file.filename}`, // ベースURLとファイルパスを組み合わせてhrefを生成
				}));
				setFiles(mappedFiles);
				setLoading(false);
			} catch (err) {
				console.error(err);
				setError("ディレクトリの取得に失敗しました。");
				setLoading(false);
			}
		};

		fetchFiles();
	}, [client, baseUrl, currentPath, navigate]);

	const handleNavigate = (path: string) => {
		navigate(`/explorer${path}`);
	};

	const handleGoBack = () => {
		const segments = getPathSegments(currentPath);
		if (segments.length > 1) {
			const parentPath = "/" + segments.slice(0, -1).join("/");
			navigate(`/explorer${parentPath}`);
		} else {
			navigate("/");
		}
	};

	const handleDelete = async (file: FileItem) => {
		try {
			if (file.type === "directory") {
				await client?.deleteFile(file.filename); // ディレクトリの場合はrecursiveオプション
			} else {
				await client?.deleteFile(file.filename); // ファイルの場合
			}
			// ファイルリストを更新
			const contents = (await client?.getDirectoryContents(currentPath)) as
				| FileStat[]
				| undefined;
			if (contents) {
				const mappedFiles: FileItem[] = contents.map((file: FileStat) => ({
					basename: file.basename,
					filename: file.filename,
					type: file.type,
					href: `${baseUrl}${file.filename}`,
				}));
				setFiles(mappedFiles);
			} else {
				setFiles([]); // contents が undefined の場合
			}
		} catch (err) {
			console.error(err);
			setError("削除に失敗しました。");
		}
	};

	const handleDownload = (file: FileItem) => {
		window.open(file.href, "_blank");
	};

	const handleViewModeChange = (
		event: React.MouseEvent<HTMLElement>,
		newViewMode: "table" | "grid" | null
	) => {
		if (newViewMode !== null) {
			setViewMode(newViewMode);
		}
	};

	return (
		<Box sx={{ display: "flex", flexDirection: "column", height: "100vh" }}>
			{/* Header */}
			<AppBar position="static">
				<Toolbar>
					<Typography variant="h6" sx={{ flexGrow: 1 }}>
						WebDAVクライアント
					</Typography>
					<Typography variant="body1" sx={{ mr: 2 }}>
						{currentPath}
					</Typography>
					<Button
						color="inherit"
						onClick={() => {
							disconnect();
							navigate("/");
						}}
					>
						切断
					</Button>
				</Toolbar>
			</AppBar>

			{/* Toolbar with View Mode Toggle */}
			<Box
				sx={{
					display: "flex",
					justifyContent: "space-between",
					alignItems: "center",
					p: 2,
				}}
			>
				<Box>
					<IconButton
						onClick={handleGoBack}
						disabled={currentPath === "/"}
						color="primary"
					>
						<ArrowBackIcon />
					</IconButton>
				</Box>
				<Box>
					<ToggleButtonGroup
						value={viewMode}
						exclusive
						onChange={handleViewModeChange}
						aria-label="view mode"
						size="small"
					>
						<ToggleButton value="table" aria-label="table view">
							<TableViewIcon />
						</ToggleButton>
						<ToggleButton value="grid" aria-label="grid view">
							<GridViewIcon />
						</ToggleButton>
					</ToggleButtonGroup>
					<Button
						variant="contained"
						startIcon={<AddIcon />}
						sx={{ ml: 2 }}
						onClick={() => navigate("/")}
					>
						新規フォルダ作成
					</Button>
					<Button
						variant="contained"
						startIcon={<UploadIcon />}
						sx={{ ml: 2 }}
						onClick={() => setUploadOpen(true)}
					>
						アップロード
					</Button>
				</Box>
			</Box>

			{/* Main Content */}
			<Box sx={{ flexGrow: 1, overflow: "auto", p: 2 }}>
				{loading ? (
					<Box
						sx={{
							display: "flex",
							justifyContent: "center",
							alignItems: "center",
							height: "100%",
						}}
					>
						<CircularProgress />
					</Box>
				) : viewMode === "table" ? (
					<TableContainer component={Paper}>
						<Table>
							<TableHead>
								<TableRow>
									<TableCell>名前</TableCell>
									<TableCell align="right">操作</TableCell>
								</TableRow>
							</TableHead>
							<TableBody>
								{files.map((file) => (
									<TableRow key={file.href}>
										<TableCell component="th" scope="row">
											<Button
												startIcon={
													file.type === "directory" ? (
														<FolderIcon />
													) : (
														<InsertDriveFileIcon />
													)
												}
												onClick={() =>
													file.type === "directory"
														? handleNavigate(file.filename)
														: null
												}
												sx={{ textTransform: "none" }}
											>
												{file.basename}
											</Button>
										</TableCell>
										<TableCell align="right">
											{file.type !== "directory" && (
												<IconButton
													aria-label="download"
													onClick={() => handleDownload(file)}
													size="small"
												>
													<DownloadIcon />
												</IconButton>
											)}
											<IconButton
												aria-label="delete"
												onClick={() => handleDelete(file)}
												size="small"
											>
												<DeleteIcon />
											</IconButton>
										</TableCell>
									</TableRow>
								))}
							</TableBody>
						</Table>
					</TableContainer>
				) : (
					<Grid container rowSpacing={6} columnSpacing={2}>
						{files.map((file) => (
							<Grid key={file.href} size={{ xs: 6, sm: 4, md: 2 }}>
								<Box
									sx={{
										border: "1px solid #ccc",
										borderRadius: "8px",
										p: 2,
										textAlign: "center",
										height: "100%",
										display: "flex",
										flexDirection: "column",
										justifyContent: "space-between",
									}}
								>
									<Box>
										<IconButton
											size="large"
											onClick={() =>
												file.type === "directory"
													? handleNavigate(file.filename)
													: null
											}
										>
											{file.type === "directory" ? (
												<FolderIcon fontSize="large" />
											) : (
												<InsertDriveFileIcon fontSize="large" />
											)}
										</IconButton>
										<Typography variant="body1" noWrap>
											{file.basename}
										</Typography>
									</Box>
									<Box>
										{file.type !== "directory" && (
											<IconButton
												aria-label="download"
												onClick={() => handleDownload(file)}
												size="small"
											>
												<DownloadIcon />
											</IconButton>
										)}
										<IconButton
											aria-label="delete"
											onClick={() => handleDelete(file)}
											size="small"
										>
											<DeleteIcon />
										</IconButton>
									</Box>
								</Box>
							</Grid>
						))}
					</Grid>
				)}
			</Box>

			{/* Upload Modal */}
			<UploadModal
				open={uploadOpen}
				handleClose={() => setUploadOpen(false)}
				currentPath={currentPath}
			/>

			{/* Error Snackbar */}
			<Snackbar
				open={!!error}
				autoHideDuration={6000}
				onClose={() => setError(null)}
				anchorOrigin={{ vertical: "bottom", horizontal: "center" }}
			>
				<Alert
					onClose={() => setError(null)}
					severity="error"
					sx={{ width: "100%" }}
				>
					{error}
				</Alert>
			</Snackbar>
		</Box>
	);
};
export default FileExplorerScreen;


##################################
./app/src/components/Upload/UploadModal.tsx
##################################

// src/components/Upload/UploadModal.tsx

import React, { useState, useContext } from "react";
import {
	Dialog,
	DialogTitle,
	DialogContent,
	DialogActions,
	Button,
	LinearProgress,
	List,
	ListItem,
	ListItemText,
	Box,
	Typography,
} from "@mui/material";
import { WebDAVContext } from "../../contexts/WebDAVContext";

interface UploadModalProps {
	open: boolean;
	handleClose: () => void;
	currentPath: string;
}

const UploadModal: React.FC<UploadModalProps> = ({
	open,
	handleClose,
	currentPath,
}) => {
	const { client } = useContext(WebDAVContext);
	const [files, setFiles] = useState<FileList | null>(null);
	const [uploading, setUploading] = useState<boolean>(false);
	const [progress, setProgress] = useState<number>(0);
	const [error, setError] = useState<string | null>(null);

	const handleFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {
		if (e.target.files) {
			setFiles(e.target.files);
		}
	};

	const handleUpload = async () => {
		if (!files || !client) return;
		setUploading(true);
		setProgress(0);
		try {
			for (let i = 0; i < files.length; i++) {
				const file = files[i];
				const arrayBuffer = await file.arrayBuffer(); // File を ArrayBuffer に変換
				await client.putFileContents(
					`${currentPath}/${file.name}`,
					arrayBuffer,
					{
						overwrite: true,
					}
				);
				setProgress(Math.round(((i + 1) / files.length) * 100));
			}
			setUploading(false);
			handleClose();
		} catch (err) {
			setError("アップロードに失敗しました。");
			setUploading(false);
		}
	};

	return (
		<Dialog open={open} onClose={handleClose} fullWidth maxWidth="sm">
			<DialogTitle>ファイルをアップロード</DialogTitle>
			<DialogContent>
				<Box
					sx={{
						border: "2px dashed #ccc",
						borderRadius: "4px",
						p: 2,
						textAlign: "center",
						cursor: "pointer",
						mb: 2,
					}}
					onClick={() => document.getElementById("file-input")?.click()}
				>
					<Typography>ここにファイルをドラッグ＆ドロップ</Typography>
				</Box>
				<input
					id="file-input"
					type="file"
					multiple
					style={{ display: "none" }}
					onChange={handleFileChange}
				/>
				{files && (
					<List>
						{Array.from(files).map((file, index) => (
							<ListItem key={index}>
								<ListItemText primary={file.name} />
							</ListItem>
						))}
					</List>
				)}
				{uploading && (
					<Box sx={{ width: "100%", mt: 2 }}>
						<LinearProgress variant="determinate" value={progress} />
						<Typography
							variant="body2"
							color="textSecondary"
						>{`${progress}% 完了`}</Typography>
					</Box>
				)}
				{error && (
					<Typography variant="body2" color="error" sx={{ mt: 2 }}>
						{error}
					</Typography>
				)}
			</DialogContent>
			<DialogActions>
				<Button onClick={handleClose} disabled={uploading}>
					キャンセル
				</Button>
				<Button
					onClick={handleUpload}
					variant="contained"
					color="primary"
					disabled={!files || uploading}
				>
					アップロード
				</Button>
			</DialogActions>
		</Dialog>
	);
};

export default UploadModal;


##################################
./app/src/components/Connection/ConnectionForm.tsx
##################################

// src/components/Connection/ConnectionForm.tsx

import React, { useState, useContext, useEffect } from "react";
import { TextField, Button, Box, Typography, Alert } from "@mui/material";
import { WebDAVContext } from "../../contexts/WebDAVContext";
import { useNavigate } from "react-router-dom";

const ConnectionForm: React.FC = () => {
	const [url, setUrl] = useState("");
	const [error, setError] = useState<string | null>(null);
	const { connect, client } = useContext(WebDAVContext);
	const navigate = useNavigate();

	const handleConnect = async () => {
		try {
			await connect(url);
			setError(null);
			navigate("/explorer");
		} catch (err) {
			setError("サーバーに接続できません。URLを確認してください。");
		}
	};

	useEffect(() => {
		if (client) {
			navigate("/explorer");
		}
	}, [client]);

	return (
		<Box
			display="flex"
			flexDirection="column"
			alignItems="center"
			justifyContent="center"
			height="100vh"
		>
			<Typography variant="h4" gutterBottom>
				WebDAVクライアントに接続
			</Typography>
			{error && (
				<Alert severity="error" sx={{ mb: 2 }}>
					{error}
				</Alert>
			)}
			<TextField
				label="サーバーURL"
				variant="outlined"
				value={url}
				onChange={(e) => setUrl(e.target.value)}
				fullWidth
				sx={{ mb: 2, maxWidth: 400 }}
			/>
			<Button variant="contained" color="primary" onClick={handleConnect}>
				接続
			</Button>
		</Box>
	);
};

export default ConnectionForm;


=================